<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å£°æ§çƒŸèŠ± Â· ä¼˜åŒ–ç‰ˆ Â· éº¦å…‹é£æ‹¾éŸ³</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        html, body {
            width: 100%;
            height: 100%;
            background: #0a0f1e;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
        }
        canvas {
            display: block;
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            z-index: 10;
            pointer-events: auto;
        }
        /* æ§åˆ¶é¢æ¿ â€” åŠé€æ˜ï¼Œä¸é®æŒ¡äº¤äº’ */
        .control-panel {
            position: fixed;
            bottom: 24px;
            right: 24px;
            z-index: 99;
            background: rgba(10, 15, 30, 0.7);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 48px;
            padding: 12px 20px;
            border: 1px solid rgba(255, 220, 150, 0.25);
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            color: #ffecdd;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 20px;
            font-size: 15px;
            pointer-events: auto;
            transition: 0.2s;
            border-left: 3px solid #ffaa66;
        }
        .control-panel:hover {
            background: rgba(20, 25, 45, 0.85);
            border-color: #ffbb77;
        }
        .control-panel label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-weight: 400;
            letter-spacing: 0.3px;
            text-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        .control-panel input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #ff8844;
            transform: scale(1);
            cursor: pointer;
            filter: drop-shadow(0 0 4px #ffaa55);
        }
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #5f6b7a;
            box-shadow: 0 0 5px currentColor;
            margin-left: 5px;
            transition: 0.2s;
        }
        .status-dot.active {
            background: #ffbb33;
            box-shadow: 0 0 12px #ffaa33;
        }
        .status-dot.error {
            background: #ff5555;
            box-shadow: 0 0 12px #ff3333;
        }
        .hint-text {
            font-size: 12px;
            color: #aaa;
            max-width: 180px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        @media (max-width: 600px) {
            .control-panel {
                bottom: 16px;
                right: 16px;
                left: 16px;
                width: auto;
                border-radius: 40px;
                justify-content: space-around;
                padding: 10px 16px;
            }
            .hint-text { max-width: 120px; }
        }
    </style>
</head>
<body>
    <canvas id="fireworksCanvas"></canvas>

    <!-- æ§åˆ¶é¢æ¿ï¼šå¤é€‰æ¡† + çŠ¶æ€æŒ‡ç¤º -->
    <div class="control-panel" id="controlPanel">
        <label>
            <input type="checkbox" id="soundToggleCheckbox"> ğŸ¤ å£°éŸ³é©±åŠ¨ï¼ˆéº¦å…‹é£æ‹¾éŸ³ï¼‰
        </label>
        <span class="status-dot" id="micStatusDot" title="éº¦å…‹é£çŠ¶æ€"></span>
        <span class="hint-text" id="statusHint">æœªå¯ç”¨</span>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

    <script>
        (function() {
            "use strict";

            // ------------------- çƒŸèŠ±å¢å¼ºç±» (éº¦å…‹é£é©±åŠ¨ç‰ˆï¼Œæ— å¼ƒç”¨API) -------------------
            var FireworksEnhanced = function(canvasElem) {
                var self = this;

                // å·¥å…·å‡½æ•°
                var rand = function(rMi, rMa) {
                    return ~~(Math.random() * (rMa - rMi + 1) + rMi);
                };

                window.requestAnimFrame = (function() {
                    return window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        window.oRequestAnimationFrame ||
                        window.msRequestAnimationFrame ||
                        function(callback) { window.setTimeout(callback, 1000 / 60); };
                })();

                // ------ éŸ³é¢‘å¼•æ“ (ä½¿ç”¨AudioBufferä»£æ›¿ScriptProcessorNode) ------
                self.audioCtx = null;
                self.isAudioReady = false;
                self.micStream = null;
                self.micSource = null;
                self.analyser = null;
                self.soundEnabled = false;
                self.lastSoundFire = 0;
                self.soundFireCooldown = 250;
                self.soundThreshold = 30;
                self.volumeAvg = 0;

                // é¢„ç”Ÿæˆçš„å™ªå£°Buffer (ç”¨äºçˆ†ç‚¸å£°)
                self.noiseBuffer = null;

                // DOM å…ƒç´ 
                self.toggleCheckbox = document.getElementById('soundToggleCheckbox');
                self.statusDot = document.getElementById('micStatusDot');
                self.statusHint = document.getElementById('statusHint');

                // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡ (æŒ‚èµ·)
                function initAudio() {
                    if (self.audioCtx) return;
                    try {
                        self.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                        self.isAudioReady = true;
                        // ç”Ÿæˆå™ªå£°Bufferï¼Œå¤ç”¨
                        self.noiseBuffer = createNoiseBuffer(self.audioCtx);
                    } catch (e) {
                        console.warn("Web Audio not supported");
                        self.statusHint.textContent = "Web Audio ä¸æ”¯æŒ";
                    }
                }
                initAudio();

                // åˆ›å»ºå™ªå£°Buffer (1ç§’çŸ­å™ªå£°)
                function createNoiseBuffer(ctx) {
                    const bufferSize = ctx.sampleRate * 0.25; // 0.25ç§’
                    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                    const output = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1; // ç™½å™ªå£°
                    }
                    return buffer;
                }

                // æ’­æ”¾çƒŸèŠ±çˆ†ç‚¸å£° (AudioBufferSourceNode)
                function playExplodeSound() {
                    if (!self.audioCtx || !self.isAudioReady || !self.noiseBuffer) return;
                    if (self.audioCtx.state === 'suspended') {
                        self.audioCtx.resume().then(() => doPlay()).catch(() => {});
                    } else if (self.audioCtx.state === 'running') {
                        doPlay();
                    }

                    function doPlay() {
                        const source = self.audioCtx.createBufferSource();
                        source.buffer = self.noiseBuffer;
                        const gainNode = self.audioCtx.createGain();
                        source.connect(gainNode);
                        gainNode.connect(self.audioCtx.destination);

                        gainNode.gain.setValueAtTime(0.25, self.audioCtx.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, self.audioCtx.currentTime + 0.25);

                        source.start();
                        source.stop(self.audioCtx.currentTime + 0.25);
                    }
                }

                // ----- è¯·æ±‚éº¦å…‹é£å¹¶å»ºç«‹åˆ†æå™¨ -----
                self.enableMicrophone = function() {
                    if (!self.audioCtx) {
                        self.statusHint.textContent = "éŸ³é¢‘ä¸Šä¸‹æ–‡ä¸å¯ç”¨";
                        return;
                    }
                    self.disableMicrophone();

                    navigator.mediaDevices.getUserMedia({ audio: true })
                        .then(function(stream) {
                            self.micStream = stream;
                            if (self.audioCtx.state === 'suspended') {
                                self.audioCtx.resume().then(() => {
                                    connectStream(stream);
                                }).catch(err => {
                                    console.warn('resumeå¤±è´¥', err);
                                    self.statusDot.className = 'status-dot error';
                                    self.statusHint.textContent = 'æ— æ³•æ¿€æ´»éŸ³é¢‘';
                                });
                            } else {
                                connectStream(stream);
                            }
                        })
                        .catch(function(err) {
                            console.error('éº¦å…‹é£æƒé™è¢«æ‹’ç»:', err);
                            self.statusDot.className = 'status-dot error';
                            self.statusHint.textContent = 'éº¦å…‹é£æƒé™æœªæˆäºˆ';
                            self.toggleCheckbox.checked = false;
                            self.soundEnabled = false;
                        });
                };

                function connectStream(stream) {
                    try {
                        self.micSource = self.audioCtx.createMediaStreamSource(stream);
                        self.analyser = self.audioCtx.createAnalyser();
                        self.analyser.fftSize = 256;
                        self.micSource.connect(self.analyser);
                        // ä¸è¿æ¥ destinationï¼Œé˜²æ­¢å›å£°

                        self.statusDot.className = 'status-dot active';
                        self.statusHint.textContent = 'æ‹¾éŸ³ä¸­';
                        self.soundEnabled = true;
                    } catch (e) {
                        console.error('è¿æ¥éº¦å…‹é£å¤±è´¥', e);
                        self.statusDot.className = 'status-dot error';
                        self.statusHint.textContent = 'éŸ³é¢‘è¿æ¥å¤±è´¥';
                        self.soundEnabled = false;
                        self.toggleCheckbox.checked = false;
                    }
                }

                self.disableMicrophone = function() {
                    if (self.micSource) {
                        try { self.micSource.disconnect(); } catch(e) {}
                        self.micSource = null;
                    }
                    if (self.micStream) {
                        self.micStream.getTracks().forEach(track => track.stop());
                        self.micStream = null;
                    }
                    self.analyser = null;
                    self.soundEnabled = false;
                    self.statusDot.className = 'status-dot';
                    self.statusHint.textContent = 'æœªå¯ç”¨';
                };

                // ----- ç»‘å®šUIäº‹ä»¶ -----
                self.setupUI = function() {
                    if (!self.toggleCheckbox) return;
                    self.toggleCheckbox.addEventListener('change', function(e) {
                        if (e.target.checked) {
                            self.enableMicrophone();
                        } else {
                            self.disableMicrophone();
                        }
                    });
                };

                // ----- åŸæœ‰å‚æ•° -----
                self.init = function() {
                    self.canvas = canvasElem;
                    self.ctx = self.canvas.getContext('2d');
                    self.resizeCanvas();

                    self.particles = [];
                    self.fireworks = [];
                    self.mx = self.cw / 2;
                    self.my = self.ch / 2;

                    self.currentHue = rand(20, 50);

                    self.partCount = 200;
                    self.partSpeed = 7;
                    self.partSpeedVariance = 14;
                    self.partWind = 30;
                    self.partFriction = 3;
                    self.partGravity = 0.8;
                    self.hueMin = 0;
                    self.hueMax = 360;
                    self.fworkSpeed = 5;
                    self.fworkAccel = 9;
                    self.hueVariance = 45;
                    self.flickerDensity = 35;
                    self.showShockwave = true;
                    self.showTarget = false;
                    self.clearAlpha = 18;

                    self.lineWidth = 1.8;

                    // ç»‘å®šç”»å¸ƒäº‹ä»¶ (ä½¿ç”¨åŸç”ŸaddEventListenerï¼Œè®¾ç½®passive)
                    self.bindCanvasEventsNative();
                    // ç»‘å®šUI
                    self.setupUI();

                    self.canvasLoop();

                    self.canvas.onselectstart = function() { return false; };
                };

                self.resizeCanvas = function() {
                    self.cw = window.innerWidth;
                    self.ch = window.innerHeight;
                    self.canvas.width = self.cw;
                    self.canvas.height = self.ch;
                    self.ctx.lineCap = 'round';
                    self.ctx.lineJoin = 'round';
                    self.ctx.lineWidth = self.lineWidth;
                };

                // ç²’å­ç³»ç»Ÿæ–¹æ³• (ä¸ä¹‹å‰ç›¸åŒ)
                self.createParticles = function(x, y, hue) {
                    playExplodeSound();

                    var count = self.partCount;
                    while (count--) {
                        var speed = rand(
                            Math.max(1, self.partSpeed - self.partSpeedVariance),
                            self.partSpeed + self.partSpeedVariance
                        );
                        var newParticle = {
                            x: x,
                            y: y,
                            coordLast: [
                                { x: x, y: y },
                                { x: x, y: y },
                                { x: x, y: y }
                            ],
                            angle: rand(0, 360),
                            speed: speed,
                            friction: 1 - self.partFriction / 100,
                            gravity: self.partGravity / 2 + (Math.random() * 0.2 - 0.1),
                            hue: rand(hue - self.hueVariance, hue + self.hueVariance),
                            brightness: rand(70, 100),
                            alpha: rand(60, 100) / 100,
                            decay: rand(5, 25) / 1000,
                            wind: (rand(0, self.partWind) - self.partWind / 2) / 25,
                            lineWidth: self.lineWidth * rand(8, 15) / 10,
                            radius: rand(1, 3)
                        };
                        self.particles.push(newParticle);
                    }
                };

                self.updateParticles = function() {
                    var i = self.particles.length;
                    while (i--) {
                        var p = self.particles[i];
                        var radians = (p.angle * Math.PI) / 180;
                        var vx = Math.cos(radians) * p.speed;
                        var vy = Math.sin(radians) * p.speed;
                        p.speed *= p.friction;

                        p.coordLast[2].x = p.coordLast[1].x;
                        p.coordLast[2].y = p.coordLast[1].y;
                        p.coordLast[1].x = p.coordLast[0].x;
                        p.coordLast[1].y = p.coordLast[0].y;
                        p.coordLast[0].x = p.x;
                        p.coordLast[0].y = p.y;

                        p.x += vx;
                        p.y += vy;
                        p.y += p.gravity;
                        p.angle += p.wind;
                        p.alpha -= p.decay;

                        if (p.x < 0 || p.x > self.cw) {
                            p.angle = 180 - p.angle;
                            if (p.x < 0) p.x = 2;
                            if (p.x > self.cw) p.x = self.cw - 2;
                            p.speed *= 0.6;
                        }
                        if (p.y < 0 || p.y > self.ch) {
                            p.angle = -p.angle;
                            if (p.y < 0) p.y = 2;
                            if (p.y > self.ch) p.y = self.ch - 2;
                            p.speed *= 0.6;
                        }

                        if (p.alpha < 0.01) {
                            self.particles.splice(i, 1);
                        }
                    }
                };

                self.drawParticles = function() {
                    var i = self.particles.length;
                    while (i--) {
                        var p = self.particles[i];
                        var coordRand = rand(0, 2);
                        self.ctx.beginPath();
                        self.ctx.moveTo(
                            Math.round(p.coordLast[coordRand].x),
                            Math.round(p.coordLast[coordRand].y)
                        );
                        self.ctx.lineTo(Math.round(p.x), Math.round(p.y));
                        self.ctx.closePath();
                        self.ctx.strokeStyle = `hsla(${p.hue}, 100%, ${p.brightness}%, ${p.alpha})`;
                        self.ctx.stroke();

                        if (self.flickerDensity > 0) {
                            var inverseDensity = 60 - self.flickerDensity;
                            if (rand(0, inverseDensity) === 0) {
                                self.ctx.beginPath();
                                self.ctx.arc(Math.round(p.x), Math.round(p.y), rand(1, 3), 0, 2 * Math.PI);
                                self.ctx.closePath();
                                var randAlpha = rand(50, 100) / 100;
                                self.ctx.fillStyle = `hsla(${p.hue}, 100%, ${p.brightness}%, ${randAlpha})`;
                                self.ctx.fill();
                            }
                        }
                    }
                };

                self.createFireworks = function(startX, startY, targetX, targetY) {
                    var angle = Math.atan2(targetY - startY, targetX - startX);
                    var newFirework = {
                        x: startX,
                        y: startY,
                        startX: startX,
                        startY: startY,
                        hitX: false,
                        hitY: false,
                        coordLast: [
                            { x: startX, y: startY },
                            { x: startX, y: startY },
                            { x: startX, y: startY }
                        ],
                        targetX: targetX,
                        targetY: targetY,
                        speed: self.fworkSpeed,
                        angle: angle,
                        shockwaveAngle: angle + 90 * (Math.PI / 180),
                        acceleration: self.fworkAccel / 100,
                        hue: self.currentHue,
                        brightness: rand(70, 100),
                        alpha: rand(70, 100) / 100,
                        lineWidth: self.lineWidth
                    };
                    self.fireworks.push(newFirework);
                };

                self.updateFireworks = function() {
                    var i = self.fireworks.length;
                    while (i--) {
                        var f = self.fireworks[i];
                        var vx = Math.cos(f.angle) * f.speed;
                        var vy = Math.sin(f.angle) * f.speed;
                        f.speed *= 1 + f.acceleration;

                        f.coordLast[2].x = f.coordLast[1].x;
                        f.coordLast[2].y = f.coordLast[1].y;
                        f.coordLast[1].x = f.coordLast[0].x;
                        f.coordLast[1].y = f.coordLast[0].y;
                        f.coordLast[0].x = f.x;
                        f.coordLast[0].y = f.y;

                        if (f.startX >= f.targetX) {
                            if (f.x + vx <= f.targetX) { f.x = f.targetX; f.hitX = true; }
                            else { f.x += vx; }
                        } else {
                            if (f.x + vx >= f.targetX) { f.x = f.targetX; f.hitX = true; }
                            else { f.x += vx; }
                        }

                        if (f.startY >= f.targetY) {
                            if (f.y + vy <= f.targetY) { f.y = f.targetY; f.hitY = true; }
                            else { f.y += vy; }
                        } else {
                            if (f.y + vy >= f.targetY) { f.y = f.targetY; f.hitY = true; }
                            else { f.y += vy; }
                        }

                        if (f.hitX && f.hitY) {
                            self.createParticles(f.targetX, f.targetY, f.hue);
                            self.fireworks.splice(i, 1);
                        }
                    }
                };

                self.drawFireworks = function() {
                    var i = self.fireworks.length;
                    self.ctx.globalCompositeOperation = 'lighter';
                    while (i--) {
                        var f = self.fireworks[i];
                        var coordRand = rand(0, 2);
                        self.ctx.beginPath();
                        self.ctx.moveTo(
                            Math.round(f.coordLast[coordRand].x),
                            Math.round(f.coordLast[coordRand].y)
                        );
                        self.ctx.lineTo(Math.round(f.x), Math.round(f.y));
                        self.ctx.closePath();
                        self.ctx.strokeStyle = `hsla(${f.hue}, 100%, ${f.brightness}%, ${f.alpha})`;
                        self.ctx.stroke();

                        if (self.showShockwave) {
                            self.ctx.save();
                            self.ctx.translate(Math.round(f.x), Math.round(f.y));
                            self.ctx.rotate(f.shockwaveAngle);
                            self.ctx.beginPath();
                            self.ctx.arc(0, 0, 1 * (f.speed / 4), 0, Math.PI, true);
                            self.ctx.strokeStyle = `hsla(${f.hue}, 100%, ${f.brightness}%, ${rand(20, 50) / 100})`;
                            self.ctx.lineWidth = f.lineWidth;
                            self.ctx.stroke();
                            self.ctx.restore();
                        }
                    }
                    self.ctx.globalCompositeOperation = 'source-over';
                };

                // ----- åŸç”Ÿäº‹ä»¶ç»‘å®šï¼ˆæ— jQueryï¼Œè®¾ç½®passiveé€‰é¡¹ï¼‰-----
                self.bindCanvasEventsNative = function() {
                    window.addEventListener('resize', function() {
                        clearTimeout(self.resizeTimeout);
                        self.resizeTimeout = setTimeout(function() { self.resizeCanvas(); }, 100);
                    });

                    // ä½¿ç”¨åŸç”Ÿäº‹ä»¶ï¼Œå…è®¸è®¾ç½® passive
                    self.canvas.addEventListener('touchstart', handleStart, { passive: false });
                    self.canvas.addEventListener('mousedown', handleStart);

                    // æ³¨æ„ï¼šmousemoveå’Œmouseupéœ€è¦åŠ¨æ€æ·»åŠ /ç§»é™¤ï¼Œä¹Ÿè¦ä½¿ç”¨åŸç”Ÿæ–¹æ³•
                    function handleStart(e) {
                        e.preventDefault();  // éœ€è¦é˜»æ­¢é»˜è®¤æ»šåŠ¨ï¼Œæ‰€ä»¥passiveå¿…é¡»ä¸ºfalse

                        if (self.audioCtx && self.audioCtx.state === 'suspended') {
                            self.audioCtx.resume();
                        }

                        var clientX, clientY;
                        if (e.type === 'mousedown') {
                            clientX = e.clientX;
                            clientY = e.clientY;
                        } else { // touchstart
                            if (e.touches.length > 0) {
                                clientX = e.touches[0].clientX;
                                clientY = e.touches[0].clientY;
                            } else return;
                        }

                        self.mx = clientX;
                        self.my = clientY;
                        self.currentHue = rand(self.hueMin, self.hueMax);
                        self.createFireworks(self.cw / 2, self.ch, self.mx, self.my);

                        // ç§»åŠ¨å¤„ç†
                        function handleMove(e) {
                            e.preventDefault();
                            var moveX, moveY;
                            if (e.type === 'mousemove') {
                                moveX = e.clientX;
                                moveY = e.clientY;
                            } else { // touchmove
                                if (e.touches.length > 0) {
                                    moveX = e.touches[0].clientX;
                                    moveY = e.touches[0].clientY;
                                } else return;
                            }
                            self.mx = moveX;
                            self.my = moveY;
                            self.currentHue = rand(self.hueMin, self.hueMax);
                            self.createFireworks(self.cw / 2, self.ch, self.mx, self.my);
                        }

                        function handleEnd(e) {
                            e.preventDefault();
                            document.removeEventListener('mousemove', handleMove);
                            document.removeEventListener('mouseup', handleEnd);
                            document.removeEventListener('touchmove', handleMove, { passive: false });
                            document.removeEventListener('touchend', handleEnd, { passive: false });
                            document.removeEventListener('touchcancel', handleEnd, { passive: false });
                        }

                        // æ·»åŠ å…¨å±€ç›‘å¬
                        document.addEventListener('mousemove', handleMove);
                        document.addEventListener('mouseup', handleEnd);
                        document.addEventListener('touchmove', handleMove, { passive: false });
                        document.addEventListener('touchend', handleEnd, { passive: false });
                        document.addEventListener('touchcancel', handleEnd, { passive: false });
                    }

                    // é˜»æ­¢é»˜è®¤è§¦æ‘¸è¡Œä¸ºï¼ˆå¯é€‰ï¼‰
                    self.canvas.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });
                };

                // ----- ä¸»å¾ªç¯ (éŸ³é‡æ£€æµ‹) -----
                self.canvasLoop = function() {
                    requestAnimFrame(self.canvasLoop, self.canvas);

                    self.ctx.globalCompositeOperation = 'source-over';
                    self.ctx.fillStyle = 'rgba(0, 0, 0, ' + self.clearAlpha / 100 + ')';
                    self.ctx.fillRect(0, 0, self.cw, self.ch);

                    if (self.soundEnabled && self.analyser) {
                        const dataArray = new Uint8Array(self.analyser.frequencyBinCount);
                        self.analyser.getByteFrequencyData(dataArray);
                        let sum = 0;
                        for (let i = 0; i < dataArray.length; i++) {
                            sum += dataArray[i];
                        }
                        let avg = sum / dataArray.length;
                        self.volumeAvg = avg;

                        if (avg > self.soundThreshold) {
                            const now = Date.now();
                            if (now - self.lastSoundFire > self.soundFireCooldown) {
                                self.lastSoundFire = now;
                                let targetX = rand(150, self.cw - 150);
                                let targetY = rand(100, self.ch - 200);
                                self.currentHue = rand(self.hueMin, self.hueMax);
                                self.createFireworks(self.cw / 2, self.ch, targetX, targetY);
                                if (avg > 120) {
                                    setTimeout(() => {
                                        self.currentHue = rand(self.hueMin, self.hueMax);
                                        self.createFireworks(self.cw / 2, self.ch, rand(150, self.cw-150), rand(100, self.ch-200));
                                    }, 30);
                                }
                            }
                        }
                    }

                    self.updateFireworks();
                    self.updateParticles();
                    self.drawFireworks();
                    self.drawParticles();
                };

                self.init();
            };

            // å¯åŠ¨çƒŸèŠ±
            var canvas = document.getElementById('fireworksCanvas');
            var fworks = new FireworksEnhanced(canvas);
            window.fworks = fworks;
        })();
    </script>
</body>
</html>