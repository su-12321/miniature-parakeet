{% extends 'blog/base.html' %}
{% load static %}

{% block title %}与 {{ other_user.username }} 的私聊 - 我的博客{% endblock %}

{% block extra_css %}
<style>
    /* 原有样式保持不变，此处省略以节省篇幅，但实际使用时保留全部原有样式 */
    body {
        background-color: #f0f2f5;
    }
    .chat-messages {
        background-color: #e5ddd5;
    }
    .message-self .message-content {
        background-color: #dcf8c6;
        color: #000;
    }
    .message-other .message-content {
        background-color: #ffffff;
        color: #333;
    }
    /* 整体卡片大小 */
    .chat-container {
        height: 90vh;
        min-height: 600px;
        max-width: 1000px;
        margin: 0 auto;
    }
    /* 消息列表区域最小高度 */
    .chat-messages {
        min-height: 450px;
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
    }
    .chat-header {
        border-bottom: 1px solid #dee2e6;
        padding: 1rem;
        background-color: #f8f9fa;
    }
    .message {
        margin-bottom: 1rem;
        max-width: 70%;
    }
    .message-self {
        margin-left: auto;
    }
    .message-other {
        margin-right: auto;
    }
    .message-content {
        padding: 0.75rem 1rem;
        border-radius: 1rem;
        position: relative;
        word-wrap: break-word;
    }
    .message-self .message-content {
        border-bottom-right-radius: 0.25rem;
    }
    .message-other .message-content {
        border: 1px solid #dee2e6;
        border-bottom-left-radius: 0.25rem;
    }
    .message-header {
        font-size: 0.8rem;
        color: #6c757d;
        margin-bottom: 0.25rem;
    }
    .message-time {
        font-size: 0.7rem;
        opacity: 0.8;
    }
    .message-self .message-time {
        text-align: right;
        color: rgba(0, 0, 0, 0.6);
    }
    .chat-input {
        border-top: 1px solid #dee2e6;
        padding: 1rem;
        background-color: white;
    }
    .typing-indicator {
        height: 20px;
        opacity: 0;
        transition: opacity 0.3s ease;
    }
    .typing-indicator.show {
        opacity: 1;
    }
    .typing-indicator span {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background-color: #6c757d;
        margin: 0 2px;
        animation: typing 1.4s infinite ease-in-out;
    }
    .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
    .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }
    @keyframes typing {
        0%, 80%, 100% { transform: scale(0); }
        40% { transform: scale(1); }
    }
    .empty-chat {
        text-align: center;
        padding: 3rem;
        color: #6c757d;
    }
    .empty-chat i {
        font-size: 3rem;
        margin-bottom: 1rem;
        opacity: 0.5;
    }
    .unread-badge {
        position: absolute;
        top: -5px;
        right: -5px;
        font-size: 0.7rem;
    }
    .nav-tabs .nav-link {
        font-size: 0.9rem;
        padding: 0.5rem 1rem;
    }
    .advanced-option {
        background-color: #f8f9fa;
        border-radius: 0.5rem;
        padding: 0.75rem;
        margin-top: 0.5rem;
    }
    /* 增加密钥显示区域的样式 */
    .key-display {
        font-family: monospace;
        word-break: break-all;
        background-color: #e9ecef;
        border-radius: 4px;
        padding: 0.5rem;
        border: 1px solid #ced4da;
    }
</style>
{% endblock %}

{% block content %}
<div class="container py-4">
    <div class="card chat-container">
        <!-- 聊天头部 -->
        <div class="chat-header position-relative">
            <div class="d-flex justify-content-between align-items-center">
                <div class="d-flex align-items-center">
                    <a href="{% url 'private_chat_list' %}" class="btn btn-sm btn-outline-secondary me-2">
                        <i class="fas fa-arrow-left"></i>
                    </a>
                    <div class="me-3 position-relative">
                        {% if other_user.profile.avatar %}
                        <img src="{{ other_user.profile.avatar.url }}"
                             class="rounded-circle border"
                             width="40" height="40"
                             alt="{{ other_user.username }}的头像"
                             style="object-fit: cover;">
                        {% else %}
                        <img src="/media/avatars/default.png"
                             class="rounded-circle border"
                             width="40" height="40"
                             alt="{{ other_user.username }}的头像"
                             style="object-fit: cover;">
                        {% endif %}
                    </div>
                    <div>
                        <h5 class="mb-0">{{ other_user.username }}</h5>
                        {% if other_user.first_name or other_user.last_name %}
                            <small class="text-muted">
                                {{ other_user.first_name }} {{ other_user.last_name }}
                            </small>
                        {% endif %}
                    </div>
                </div>
                <div>
                    <a href="{% url 'private_chat_list' %}" class="btn btn-sm btn-outline-primary">
                        <i class="fas fa-list"></i> 会话列表
                    </a>
                </div>
            </div>
        </div>

        <!-- 标签页：普通 / 高级 -->
        <div class="px-4 pt-3">
            <ul class="nav nav-tabs" id="chatModeTab" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="normal-tab" data-bs-toggle="tab" data-bs-target="#normal" type="button" role="tab">普通聊天</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="advanced-tab" data-bs-toggle="tab" data-bs-target="#advanced" type="button" role="tab">高级聊天</button>
                </li>
            </ul>
            <div class="tab-content pt-3">
                <!-- 普通模式选项 -->
                <div class="tab-pane active" id="normal" role="tabpanel">
                    <div class="mb-2">
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="checkbox" id="normalBurnAfterReading">
                            <label class="form-check-label" for="normalBurnAfterReading">阅后即焚</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="checkbox" id="normalTimedBurn">
                            <label class="form-check-label" for="normalTimedBurn">定时销毁</label>
                        </div>
                        <div class="row mt-2" id="normalBurnTimePicker" style="display: none;">
                            <div class="col-md-6">
                                <input type="datetime-local" class="form-control form-control-sm" id="normalBurnAt">
                            </div>
                        </div>
                    </div>
                </div>
                <!-- 高级模式选项（增加密钥生成功能） -->
                <div class="tab-pane" id="advanced" role="tabpanel">
                    <div class="advanced-option">
                        <label for="customPassword" class="form-label">共享密码（端到端加密）</label>
                        <div class="input-group">
                            <input type="password" class="form-control" id="customPassword" placeholder="输入密码">
                            <button class="btn btn-outline-secondary" type="button" id="generateKeyBtn" title="生成随机密钥">
                                <i class="fas fa-key"></i>
                            </button>
                            <button class="btn btn-outline-secondary" type="button" id="togglePasswordVisibility" title="显示/隐藏密码">
                                <i class="fas fa-eye"></i>
                            </button>
                        </div>
                        <small class="text-muted">密码不会发送到服务器，请确保与对方提前共享</small>
                        <!-- 密钥显示区域（初始隐藏） -->
                        <div class="mt-2" id="keyDisplayArea" style="display: none;">
                            <div class="alert alert-info p-2 mb-0 d-flex align-items-center">
                                <strong class="me-2">生成的密钥：</strong>
                                <code id="generatedKey" class="flex-grow-1 key-display"></code>
                                <button class="btn btn-sm btn-link ms-2" id="copyKeyBtn" title="复制到剪贴板">
                                    <i class="fas fa-copy"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="form-check mt-2">
                        <input class="form-check-input" type="checkbox" id="advancedBurnAfterReading">
                        <label class="form-check-label" for="advancedBurnAfterReading">阅后即焚</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="advancedTimedBurn">
                        <label class="form-check-label" for="advancedTimedBurn">定时销毁</label>
                    </div>
                    <div class="row mt-2" id="advancedBurnTimePicker" style="display: none;">
                        <div class="col-md-6">
                            <input type="datetime-local" class="form-control form-control-sm" id="advancedBurnAt">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 消息区域 -->
        <div class="chat-messages" id="chatMessages">
            <div class="empty-chat" id="emptyChatMessage">
                <i class="fas fa-comments"></i>
                <h5 class="mt-3">还没有消息</h5>
                <p class="text-muted">发送第一条消息开始对话</p>
            </div>
        </div>

        <!-- 输入区域 -->
        <div class="chat-input">
            <form id="messageForm">
                <div class="input-group">
                    <textarea name="content" id="id_content" class="form-control"
                              rows="1" placeholder="输入消息..." required></textarea>
                    <button type="submit" class="btn btn-primary" id="sendButton">
                        <i class="fas fa-paper-plane"></i> 发送
                    </button>
                </div>
                <small class="text-muted mt-1 d-block">
                    按 Enter 发送，Shift+Enter 换行
                </small>
            </form>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    // ========== 配置 ==========
    const otherUserId = {{ other_user.id }};
    const currentUserId = {{ request.user.id }};

    // ========== 辅助函数 ==========
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function scrollToBottom() {
        const container = document.getElementById('chatMessages');
        if (container) {
            container.scrollTop = container.scrollHeight;
        }
    }

    // ========== WebSocket 连接管理 ==========
    let chatSocket = null;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 10;
    let heartbeatInterval = null;

    function connectWebSocket() {
        if (chatSocket && chatSocket.readyState === WebSocket.OPEN) return;

        chatSocket = new WebSocket('ws://' + window.location.host + '/ws/private/' + otherUserId + '/');

        chatSocket.onopen = function() {
            console.log('WebSocket connected');
            reconnectAttempts = 0;
            if (heartbeatInterval) clearInterval(heartbeatInterval);
            heartbeatInterval = setInterval(() => {
                if (chatSocket.readyState === WebSocket.OPEN) {
                    chatSocket.send(JSON.stringify({'type': 'ping'}));
                }
            }, 30000);
        };

        chatSocket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            console.log('WebSocket 收到消息:', data);
            if (data.type === 'message') {
                appendMessage(data);
            } else if (data.type === 'pong') {
                // 心跳响应，忽略
            } else if (data.type === 'error') {
                if (typeof BlogUtils !== 'undefined') {
                    BlogUtils.showNotification('发送失败：' + data.message, 'danger');
                } else {
                    alert('发送失败：' + data.message);
                }
            }
        };

        chatSocket.onclose = function(e) {
            console.log('WebSocket closed:', e.code, e.reason);
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
            if (reconnectAttempts < maxReconnectAttempts) {
                reconnectAttempts++;
                setTimeout(connectWebSocket, 3000);
            } else {
                if (typeof BlogUtils !== 'undefined') {
                    BlogUtils.showNotification('连接失败，请刷新页面重试', 'danger');
                } else {
                    alert('连接失败，请刷新页面重试');
                }
            }
        };

        chatSocket.onerror = function(error) {
            console.error('WebSocket error:', error);
        };
    }

    // ========== UI 控制：定时销毁时间选择器 ==========
    document.getElementById('normalTimedBurn').addEventListener('change', function(e) {
        document.getElementById('normalBurnTimePicker').style.display = e.target.checked ? 'block' : 'none';
    });
    document.getElementById('advancedTimedBurn').addEventListener('change', function(e) {
        document.getElementById('advancedBurnTimePicker').style.display = e.target.checked ? 'block' : 'none';
    });

    // ========== 密钥生成与显示功能 ==========
    function generateRandomKey(length = 32) {
        const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()';
        let result = '';
        const values = new Uint8Array(length);
        crypto.getRandomValues(values);
        for (let i = 0; i < length; i++) {
            result += charset[values[i] % charset.length];
        }
        return result;
    }

    document.getElementById('togglePasswordVisibility').addEventListener('click', function() {
        const pwdInput = document.getElementById('customPassword');
        const type = pwdInput.getAttribute('type') === 'password' ? 'text' : 'password';
        pwdInput.setAttribute('type', type);
        const icon = this.querySelector('i');
        if (icon) {
            icon.classList.toggle('fa-eye');
            icon.classList.toggle('fa-eye-slash');
        }
    });

    document.getElementById('generateKeyBtn').addEventListener('click', function() {
        const key = generateRandomKey(32);
        document.getElementById('customPassword').value = key;
        document.getElementById('generatedKey').textContent = key;
        document.getElementById('keyDisplayArea').style.display = 'block';
    });

    document.getElementById('copyKeyBtn').addEventListener('click', function() {
        const key = document.getElementById('generatedKey').textContent;
        navigator.clipboard.writeText(key).then(() => {
            if (typeof BlogUtils !== 'undefined') {
                BlogUtils.showNotification('密钥已复制到剪贴板', 'success');
            } else {
                alert('密钥已复制');
            }
        }).catch(err => {
            if (typeof BlogUtils !== 'undefined') {
                BlogUtils.showNotification('复制失败', 'danger');
            } else {
                alert('复制失败');
            }
        });
    });

    // ========== 辅助函数：获取当前模式及选项 ==========
    function getCurrentMode() {
        const activeTab = document.querySelector('#chatModeTab .nav-link.active');
        return activeTab.id === 'normal-tab' ? 'normal' : 'advanced';
    }

    function getBurnAfterReading() {
        const mode = getCurrentMode();
        return mode === 'normal'
            ? document.getElementById('normalBurnAfterReading').checked
            : document.getElementById('advancedBurnAfterReading').checked;
    }

    function getBurnAt() {
        const mode = getCurrentMode();
        if (mode === 'normal') {
            if (!document.getElementById('normalTimedBurn').checked) return null;
            const val = document.getElementById('normalBurnAt').value;
            return val ? new Date(val).toISOString() : null;
        } else {
            if (!document.getElementById('advancedTimedBurn').checked) return null;
            const val = document.getElementById('advancedBurnAt').value;
            return val ? new Date(val).toISOString() : null;
        }
    }

    function getCustomPassword() {
        if (getCurrentMode() !== 'advanced') return null;
        const pwd = document.getElementById('customPassword').value.trim();
        return pwd || null;
    }

    // ========== 自定义加密类 (Web Crypto API) ==========
    class CustomCrypto {
        constructor(password) {
            this.password = password;
        }

        async deriveKey(salt) {
            const enc = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                enc.encode(this.password),
                { name: 'PBKDF2' },
                false,
                ['deriveKey']
            );
            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
        }

        // 将 Uint8Array 转为 Base64 字符串（安全处理大数组）
        _uint8ArrayToBase64(u8) {
            let binary = '';
            for (let i = 0; i < u8.length; i++) {
                binary += String.fromCharCode(u8[i]);
            }
            return btoa(binary);
        }

        async encrypt(plaintext) {
            try {
                const salt = crypto.getRandomValues(new Uint8Array(16));
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const key = await this.deriveKey(salt);

                const enc = new TextEncoder();
                const ciphertext = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    enc.encode(plaintext)
                );

                const result = new Uint8Array(salt.length + iv.length + ciphertext.byteLength);
                result.set(salt, 0);
                result.set(iv, salt.length);
                result.set(new Uint8Array(ciphertext), salt.length + iv.length);

                const base64 = this._uint8ArrayToBase64(result);
                console.log('加密成功，Base64长度:', base64.length);
                return base64;
            } catch (e) {
                console.error('加密失败:', e);
                throw e;
            }
        }

        async decrypt(encryptedBase64) {
            const binary = atob(encryptedBase64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }

            const salt = bytes.slice(0, 16);
            const iv = bytes.slice(16, 28);
            const ciphertext = bytes.slice(28);

            const key = await this.deriveKey(salt);

            const decrypted = await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                ciphertext
            );

            const dec = new TextDecoder();
            return dec.decode(decrypted);
        }
    }

    // ========== 发送消息 ==========
    async function sendMessage(rawMessage) {
        const mode = getCurrentMode();
        let encryptedContent = rawMessage;
        let encryptionType = 'system';

        if (mode === 'advanced') {
            const password = getCustomPassword();
            if (password) {
                try {
                    const crypto = new CustomCrypto(password);
                    encryptedContent = await crypto.encrypt(rawMessage);
                    encryptionType = 'custom';
                } catch (e) {
                    if (typeof BlogUtils !== 'undefined') {
                        BlogUtils.showNotification('加密失败：' + e.message, 'danger');
                    } else {
                        alert('加密失败：' + e.message);
                    }
                    return false;
                }
            } else {
                if (typeof BlogUtils !== 'undefined') {
                    BlogUtils.showNotification('高级模式需要输入共享密码', 'warning');
                } else {
                    alert('高级模式需要输入共享密码');
                }
                return false;
            }
        }

        const payload = {
            type: 'message',
            message: encryptedContent,
            encryption_type: encryptionType,
            is_burn_after_reading: getBurnAfterReading(),
            burn_at: getBurnAt()
        };
        console.log('发送消息 payload:', payload);

        if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
            chatSocket.send(JSON.stringify(payload));
            return true;
        } else {
            if (typeof BlogUtils !== 'undefined') {
                BlogUtils.showNotification('连接已断开，请稍后重试', 'warning');
            } else {
                alert('连接已断开，请稍后重试');
            }
            return false;
        }
    }

    // ========== 接收消息并显示（兼容 WebSocket 和 API） ==========
    async function appendMessage(data) {
        try {
            console.log('appendMessage 被调用, 数据:', data);
            const isSelf = (data.sender_id === currentUserId);
            let displayContent = '';

            // 兼容处理消息内容字段（WebSocket 用 message，API 用 content）
            const rawContent = data.message || data.content || '';

            if (data.destroyed_at) {
                displayContent = '<em class="text-muted">[消息已销毁]</em>';
            } else {
                if (data.encryption_type === 'system') {
                    displayContent = escapeHtml(rawContent);
                } else {
                    // 自定义加密：尝试用当前密码解密
                    const password = getCustomPassword();
                    if (password) {
                        try {
                            const crypto = new CustomCrypto(password);
                            const plain = await crypto.decrypt(rawContent);
                            displayContent = escapeHtml(plain);
                        } catch (e) {
                            displayContent = '<span class="text-danger">[解密失败，密码错误]</span>';
                        }
                    } else {
                        displayContent = '<span class="text-warning">[加密消息，请输入密码查看]</span>';
                    }
                }
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isSelf ? 'message-self' : 'message-other'}`;
            messageDiv.innerHTML = `
                <div class="message-header">${isSelf ? '你' : escapeHtml(data.sender_username)}</div>
                <div class="message-content">${displayContent}</div>
                <div class="message-time">
                    ${new Date(data.created_at).toLocaleTimeString()}
                    ${data.is_burn_after_reading ? '<span class="badge bg-warning ms-2">阅后即焚</span>' : ''}
                    ${data.burn_at ? '<span class="badge bg-info ms-2">定时销毁</span>' : ''}
                </div>
            `;

            const container = document.getElementById('chatMessages');
            if (container) {
                container.appendChild(messageDiv);
                scrollToBottom();
                // 隐藏空状态提示
                document.getElementById('emptyChatMessage').style.display = 'none';
            } else {
                console.error('聊天消息容器未找到');
            }
        } catch (error) {
            console.error('appendMessage 出错:', error);
        }
    }

    // ========== 加载历史消息（增量） ==========
    let lastMessageId = null;
    async function loadMessages() {
        let url = '/api/private-chat/messages/' + otherUserId + '/';
        if (lastMessageId) {
            url += '?last_id=' + lastMessageId;
        }
        try {
            const response = await fetch(url);
            const data = await response.json();
            console.log('loadMessages 响应:', data);
            if (data.messages && data.messages.length > 0) {
                for (const msg of data.messages) {
                    await appendMessage(msg);
                }
                lastMessageId = data.messages[data.messages.length - 1].id;
            }
        } catch (error) {
            console.error('加载消息失败:', error);
        }
    }

    // ========== 页面初始化 ==========
    document.addEventListener('DOMContentLoaded', function() {
        connectWebSocket();
        loadMessages();

        // 表单提交
        document.getElementById('messageForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            const input = document.getElementById('id_content');
            const message = input.value.trim();
            if (message) {
                const sent = await sendMessage(message);
                if (sent) {
                    input.value = '';
                }
            }
        });

        // 输入框高度自适应
        const input = document.getElementById('id_content');
        input.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 120) + 'px';
        });

        // 快捷键：Enter 发送，Shift+Enter 换行
        input.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                document.getElementById('messageForm').requestSubmit();
            }
        });
    });

    // ========== 页面可见性变化 ==========
    document.addEventListener('visibilitychange', function() {
        if (!document.hidden && (!chatSocket || chatSocket.readyState === WebSocket.CLOSED)) {
            connectWebSocket();
        }
    });

    // ========== 页面关闭前清理 ==========
    window.addEventListener('beforeunload', function() {
        if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
            chatSocket.close();
        }
        if (heartbeatInterval) clearInterval(heartbeatInterval);
    });
</script>
{% endblock %}